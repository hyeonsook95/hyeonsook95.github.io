---
layout: post
title:  "백준 3085 사탕게임"
date:   2020-04-03
excerpt: "못 풀었던 문제, 힘들게 풀었던 문제 풀이"
categories: 
 - Algorithms
tag:
 - algorithms
 - beakjoon
---

## 문제

상근이는 어렸을 적에 "봄보니 (Bomboni)" 게임을 즐겨했다.
    
가장 처음에 N×N크기에 사탕을 채워 놓는다. 사탕의 색은 모두 같지 않을 수도 있다. 상근이는 사탕의 색이 다른 인접한 두 칸을 고른다. 그 다음 고른 칸에 들어있는 사탕을 서로 교환한다. 이제, 모두 같은 색으로 이루어져 있는 가장 긴 연속 부분(행 또는 열)을 고른 다음 그 사탕을 모두 먹는다.
    
사탕이 채워진 상태가 주어졌을 때, 상근이가 먹을 수 있는 사탕의 최대 개수를 구하는 프로그램을 작성하시오.

## 측정 시간

|문제풀이 방법 떠올린 시간|코드로 구현한 시간|디버그한 시간|
|:--:|:--:|:--:|
| 19m 35s| 20m 10s| 1h 20m|

## 문제풀이 방법

1. 그 칸에서 행끼리 바꿀 수 있다면
  1. 행의 두 칸을 swap하여 바꾼다.
  2. 체크함수로 보낸다.
    1. 바뀐 N*N 행렬의 N행에서의 최대의 사탕의 개수를 검사한다.
    2. 바뀐 N*N 행렬의 N열에서의 최대의 사탕의 개수를 검사한다.
  3. 바뀐 행렬의 최대의 사탕의 개수와 현재 max 값을 비교하고 최대값을 max에 저장한다.
2. 그 칸에서 열끼리 바꿀 수 있다면
  1. 열의 두 칸을 swap하여 바꾼다.
  2. 체크함수로 보낸다.
    1. 바뀐 N*N 행렬의 N행에서의 최대의 사탕의 개수를 검사한다.
    2. 바뀐 N*N 행렬의 N열에서의 최대의 사탕의 개수를 검사한다.
  3. 바뀐 행렬의 최대의 사탕의 개수와 현재 max 값을 비교하고 최대값을 max에 저장한다.

## 풀이 평가

* 문제풀이 방법을 떠올린 시간은 강의를 한 번 듣고 문제를 푼 것이므로 카운트하지 않음
* 1차적으로 코드로 구현하는 데는 오래걸리지 않았음
* 하지만 논리적 오류로 코드가 예제 데이터도 풀지 못함

### 풀이 문제점
나는 위의 문제풀이 방법을 구현하기 위해 **메인 함수, 체크 함수**로 나누었다. 문제가 되었던 부분은 체크 함수였다. N행과 N열만을 검사하도록 현재 x, y 좌표를 체크함수에 넘겨주고 N행을 검사할 때는 열의 값을 고정하고, N열을 검사할 때는 행의 값을 고정한 후 검사하는 함수를 `for문`으로 구현하였다.

```c++
int check(vector<string> &c, int a, int b)
{
  int i = 0;
  int max = 0, cnt = 0;
  for (int i = 0; i < n - 1; i++)
  {
      if (c[i][b] == c[i + 1][b])
          cnt++;
      else
      {
          cnt++;
          if (max < cnt)
              max = cnt;
          cnt = 0;
      }
  }
  cnt = 0;
  
  for (int i = 0; i < n - 1; i++)
  {

      if (c[a][i] == c[a][i + 1])
          cnt++;
      else
      {
          cnt++;
          if (max < cnt)
              max = cnt;
          cnt = 0;
      }
  }
  return max;
}
```

그런데 여기서 계속 오류가 일어났다. `for문`과 `if문`의 조합의 문제였다. 백준님은 `while문`을 사용해서 구현했는데, 왜 그랬는지 깨닫는 계기가 되었다.
  
차근차근 잘 살펴보자.

```c++
for (int i = 0; i < n - 1; i++)
  {

    if (c[a][i] == c[a][i + 1])
        cnt++;
  ...
```
위의 코드에서 보면 `i`번째 배열과 `i+1`번째 배열을 비교하고 있다. 그리고 그 두 배열의 값을 비교하기 위해 `for문`의 조건도 `i <= 1 < n-1`로 선언했다. 다음이 오류가 일어나는 곳이다. `else문`.

```c++
...
    else
      {
          cnt++;
          if (max < cnt)
              max = cnt;
          cnt = 0;
      }
  }
```

`else문`은 배열 `i`와 `i+1`의 값이 같지 않을 때, 현재 가장 큰 값으로 있는 `max` 변수와 비교하고 `cnt`의 값이 더 크면 `max`에 `cnt`를 저장한 후 `cnt`를 초기화한다.
  
여기서 문제가 생긴다. `i`가 반복문의 마지막 순서를 실행하고, `if문`만 실행한 후 반복문이 종료된다면? 그러니까, 연속된 사탕이 마지막 행 또는 열까지 이어졌다면? 마지막 행 또는 열까지 사탕의 개수를 센 `cnt`는 `max`값과 비교하지 못한 채 0으로 초기화된다.

그래서 `max` 값이 다 비교되지 못하고 나오게 되는 것이다.

### 개선점

* 값을 비교할 때, 끝의 값까지 모두 비교했는지 잘 생각하기
* 값을 비교하는 문제는 `for문` 보다는 `while 문`(되도록 모든 연산이 끝난 후 비교하기 위해 `while문`)

---
* [사탕게임](https://www.acmicpc.net/problem/3085)